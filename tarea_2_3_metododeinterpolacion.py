# -*- coding: utf-8 -*-
"""Tarea 2.3_MetodoDeInterpolacion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UEJIaZxuU3MASc9MfP0-jPeLclq6H2sT
"""

#Antonio Josue Rodriguez Falcon

import numpy as np
import matplotlib.pyplot as plt

# Función original
def f(x):
    return x**3 - 4*x + 1

# Interpolación de Lagrange
def lagrange_interpolation(x, x_points, y_points):
    n = len(x_points)
    result = 0
    for i in range(n):
        term = y_points[i]
        for j in range(n):
            if i != j:
                term *= (x - x_points[j]) / (x_points[i] - x_points[j])
        result += term
    return result

# Método de Bisección
def bisect(func, a, b, tol=1e-6, max_iter=100):
    if func(a) * func(b) > 0:
        raise ValueError("El intervalo no contiene una raíz")

    for _ in range(max_iter):
        c = (a + b) / 2
        if abs(func(c)) < tol or (b - a) / 2 < tol:
            return c
        if func(a) * func(c) < 0:
            b = c
        else:
            a = c
    return (a + b) / 2  # Retorna la mejor estimación de la raíz

# Selección de tres puntos de interpolación
x0 = 1.0
x1 = 1.5
x2 = 3.0
x_points = np.array([x0, x1, x2])
y_points = f(x_points)

# Construcción del polinomio interpolante
# mediante interpolacion de Lagrange
x_vals = np.linspace(x0, x2, 100)
y_interp = [lagrange_interpolation(x, x_points, y_points) for x in x_vals]

# Encontrar raíz del polinomio interpolante usando bisección
# en el intervalo inducido por los puntos donde se hace la interpolacion
root = bisect(lambda x: lagrange_interpolation(x, x_points, y_points), x0, x2)

# Gráfica
plt.figure(figsize=(8, 6))
plt.plot(x_vals, f(x_vals), label="f(x) = x^3 - 4x + 1", linestyle='dashed', color='blue')
plt.plot(x_vals, y_interp, label="Interpolación de Lagrange", color='red')
plt.axhline(0, color='black', linewidth=0.5, linestyle='--')
plt.axvline(root, color='green', linestyle='dotted', label=f"Raíz aproximada: {root:.4f}")
plt.scatter(x_points, y_points, color='black', label="Puntos de interpolación")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.title("Interpolación y búsqueda de raíces")
plt.legend()
plt.grid(True)
plt.savefig("interpolacion_raices.png")  # Guarda la imagen
plt.show()

# Imprimir la raíz encontrada
print(f"La raíz aproximada usando interpolación es: {root:.4f}")

#Antonio Josue Rodriguez Falcon
#Ejercicio 1

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Función original
def f(x):
    return x**3 - 6*x**2 + 11*x - 6

# Interpolación de Lagrange
def lagrange_interpolation(x, x_points, y_points):
    n = len(x_points)
    result = 0
    for i in range(n):
        term = y_points[i]
        for j in range(n):
            if i != j:
                term *= (x - x_points[j]) / (x_points[i] - x_points[j])
        result += term
    return result

# Método de Bisección
def bisect(func, a, b, tol=1e-6, max_iter=100):
    if func(a) * func(b) > 0:
        raise ValueError("El intervalo no contiene una raíz")

    for _ in range(max_iter):
        c = (a + b) / 2
        if abs(func(c)) < tol or (b - a) / 2 < tol:
            return c
        if func(a) * func(c) < 0:
            b = c
        else:
            a = c
    return (a + b) / 2  # Retorna la mejor estimación de la raíz

# Selección de tres puntos de interpolación
x0, x1, x2 = 1.0, 2.0, 3.0
x_points = np.array([x0, x1, x2])
y_points = f(x_points)

# Construcción del polinomio interpolante
x_vals = np.linspace(x0, x2, 100)
y_interp = np.array([lagrange_interpolation(x, x_points, y_points) for x in x_vals])

# Encontrar raíz del polinomio interpolante usando bisección
root = bisect(lambda x: lagrange_interpolation(x, x_points, y_points), x0, x2)

# Errores
error_absoluto = np.abs(f(x_vals) - y_interp)
error_relativo = np.abs(error_absoluto / f(x_vals))
error_cuadratico = error_absoluto**2

# Crear DataFrame de errores
df_errores = pd.DataFrame({
    'x': x_vals,
    'Error Absoluto': error_absoluto,
    'Error Relativo': error_relativo,
    'Error Cuadrático': error_cuadratico
})

# Mostrar tabla de errores
print(df_errores.head(10))  # Muestra las primeras 10 filas

# Graficar errores
fig, axs = plt.subplots(3, 1, figsize=(8, 12))

axs[0].plot(x_vals, error_absoluto, label="Error absoluto", color='purple')
axs[0].set_title("Error absoluto")
axs[0].grid(True)

axs[1].plot(x_vals, error_relativo, label="Error relativo", color='orange')
axs[1].set_title("Error relativo")
axs[1].grid(True)

axs[2].plot(x_vals, error_cuadratico, label="Error cuadrático", color='brown')
axs[2].set_title("Error cuadrático")
axs[2].grid(True)

plt.tight_layout()
plt.show()

# Imprimir la raíz encontrada
print(f"La raíz aproximada usando interpolación es: {root:.4f}")

#Antonio Josue Rodriguez Falcon
#Ejercicio 2

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import lagrange
import pandas as pd

# Definir la función dada
def f(x):
    return np.sin(x) - x / 2

# Definir los tres puntos equidistantes en el intervalo [0, 2]
x_points = np.linspace(0, 2, 3)
y_points = f(x_points)

# Construcción del polinomio interpolante con Lagrange
poly = lagrange(x_points, y_points)

# Encontrar raíz del polinomio interpolante usando bisección
def bisect(func, a, b, tol=1e-6, max_iter=100):
    if func(a) * func(b) > 0:
        raise ValueError("El intervalo no contiene una raíz")

    iter_count = 0
    errors = []

    for _ in range(max_iter):
        c = (a + b) / 2
        error = abs(func(c))
        errors.append(error)

        if error < tol or (b - a) / 2 < tol:
            return c, errors

        if func(a) * func(c) < 0:
            b = c
        else:
            a = c

        iter_count += 1

    return (a + b) / 2, errors

root, errors = bisect(poly, 0, 2)

# Crear tabla de iteraciones y errores
data = {"Iteración": list(range(1, len(errors) + 1)), "Error": errors}
df = pd.DataFrame(data)
print(df)

# Graficar la función y el polinomio interpolante
x_vals = np.linspace(0, 2, 100)
y_vals = f(x_vals)
y_interp = poly(x_vals)

plt.figure(figsize=(8, 6))
plt.plot(x_vals, y_vals, label="f(x) = sin(x) - x/2", linestyle='dashed', color='blue')
plt.plot(x_vals, y_interp, label="Interpolación de Lagrange", color='red')
plt.axhline(0, color='black', linewidth=0.5, linestyle='--')
plt.axvline(root, color='green', linestyle='dotted', label=f"Raíz aproximada: {root:.4f}")
plt.scatter(x_points, y_points, color='black', label="Puntos de interpolación")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.title("Interpolación y búsqueda de raíces")
plt.legend()
plt.grid(True)
plt.show()

# Gráfico de convergencia de errores
plt.figure(figsize=(8, 6))
plt.plot(errors, marker='o', linestyle='-', color='purple')
plt.yscale("log")
plt.xlabel("Iteración")
plt.ylabel("Error absoluto")
plt.title("Convergencia del método de bisección")
plt.grid(True)
plt.show()

# Graficar los errores en escala normal
plt.figure(figsize=(8, 6))
plt.plot(errors, marker='s', linestyle='-', color='red')
plt.xlabel("Iteración")
plt.ylabel("Error absoluto")
plt.title("Error absoluto en cada iteración")
plt.grid(True)
plt.show()

# Graficar los errores en escala log-log
plt.figure(figsize=(8, 6))
plt.plot(errors, marker='^', linestyle='-', color='green')
plt.xscale("log")
plt.yscale("log")
plt.xlabel("Iteración (escala log)")
plt.ylabel("Error absoluto (escala log)")
plt.title("Error absoluto en escala log-log")
plt.grid(True)
plt.show()

# Imprimir la raíz encontrada
print(f"La raíz aproximada usando interpolación es: {root:.6f}")

#Antonio Josue Rodriguez Falcon
#Ejercicio 3

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Función dada

def f(x):
    return np.exp(-x) - x

# Interpolación de Lagrange
def lagrange_interpolation(x, x_points, y_points):
    n = len(x_points)
    result = 0
    for i in range(n):
        term = y_points[i]
        for j in range(n):
            if i != j:
                term *= (x - x_points[j]) / (x_points[i] - x_points[j])
        result += term
    return result

# Definir puntos de interpolación
x_points = np.array([0.0, 0.25, 0.5, 0.75, 1.0])
y_points = f(x_points)

# Construcción del polinomio interpolante
test_x = np.linspace(0, 1, 100)
interp_y = np.array([lagrange_interpolation(x, x_points, y_points) for x in test_x])
true_y = f(test_x)
error = np.abs(true_y - interp_y)
error_cuadratico = error**2
error_relativo = np.abs(error / true_y)

# Encontrar raíz de la interpolación con método de bisección
def bisect(func, a, b, tol=1e-6, max_iter=100):
    if func(a) * func(b) > 0:
        raise ValueError("El intervalo no contiene una raíz")
    for _ in range(max_iter):
        c = (a + b) / 2
        if abs(func(c)) < tol or (b - a) / 2 < tol:
            return c
        if func(a) * func(c) < 0:
            b = c
        else:
            a = c
    return (a + b) / 2

root = bisect(lambda x: lagrange_interpolation(x, x_points, y_points), 0, 1)

# Graficar la función, interpolación y errores
plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
plt.plot(test_x, true_y, label='f(x) = e^(-x) - x', linestyle='dashed', color='blue')
plt.plot(test_x, interp_y, label='Interpolación de Lagrange', color='red')
plt.axhline(0, color='black', linewidth=0.5, linestyle='--')
plt.axvline(root, color='green', linestyle='dotted', label=f'Raíz aproximada: {root:.6f}')
plt.scatter(x_points, y_points, color='black', label='Puntos de interpolación')
plt.xlabel("x")
plt.ylabel("f(x)")
plt.title("Interpolación de Lagrange")
plt.legend()
plt.grid(True)

plt.subplot(1, 3, 2)
plt.plot(test_x, error, label='Error absoluto', color='purple')
plt.xlabel("x")
plt.ylabel("Error")
plt.title("Error Absoluto")
plt.legend()
plt.grid(True)

plt.subplot(1, 3, 3)
plt.plot(test_x, error_cuadratico, label='Error cuadrático', color='orange')
plt.plot(test_x, error_relativo, label='Error relativo', color='green')
plt.xlabel("x")
plt.ylabel("Error")
plt.title("Errores Cuadrático y Relativo")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.savefig("interpolacion_errores.png")
plt.show()

# Crear tabla de valores
results_df = pd.DataFrame({
    "x": test_x,
    "f(x)": true_y,
    "Interpolación": interp_y,
    "Error absoluto": error,
    "Error cuadrático": error_cuadratico,
    "Error relativo": error_relativo
})

# Mostrar la raíz y tabla de errores
print(f"Raíz aproximada: {root:.6f}")
print(results_df.head(10))